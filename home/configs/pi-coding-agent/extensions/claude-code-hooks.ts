/**
 * Claude Code hooks bridge for pi agent
 *
 * Reads .claude/settings.json (e.g. generated by devenv's claude.code.enable)
 * and executes those hooks inside pi. Supports PreToolUse and PostToolUse hooks.
 *
 * Hook commands receive Claude Code-compatible JSON via stdin with:
 *   { session_id, cwd, hook_event_name, tool_name, tool_input }
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { spawn } from "node:child_process";
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

// --- Types ---

interface HookHandler {
  type: "command";
  command: string;
}

interface MatcherGroup {
  matcher?: string;
  hooks: HookHandler[];
}

interface HooksConfig {
  hooks?: {
    PreToolUse?: MatcherGroup[];
    PostToolUse?: MatcherGroup[];
    Stop?: MatcherGroup[];
  };
}

// --- Tool name mapping (pi lowercase → Claude Code capitalized) ---

const TOOL_NAME_MAP: Record<string, string> = {
  edit: "Edit",
  write: "Write",
  bash: "Bash",
  read: "Read",
  grep: "Grep",
  find: "Glob",
  ls: "Ls",
};

function mapToolName(piName: string): string {
  return TOOL_NAME_MAP[piName] ?? piName;
}

// --- Build Claude Code-compatible tool_input from pi event input ---

function buildToolInput(
  piToolName: string,
  input: Record<string, unknown>,
): Record<string, unknown> {
  if (piToolName === "edit" || piToolName === "write") {
    return { file_path: input.path, ...input };
  }
  if (piToolName === "bash") {
    return { command: input.command, ...input };
  }
  return { ...input };
}

// --- Execute a hook command with JSON piped to stdin ---

function execHookCommand(
  command: string,
  stdinJson: string,
  cwd: string,
  timeout: number,
): Promise<{ stdout: string; stderr: string; code: number }> {
  return new Promise((resolve) => {
    const child = spawn("sh", ["-c", command], {
      cwd,
      stdio: ["pipe", "pipe", "pipe"],
      env: {
        ...process.env,
        DEVENV_ROOT: cwd,
      },
      timeout,
    });

    let stdout = "";
    let stderr = "";

    child.stdout.on("data", (data: Buffer) => {
      stdout += data.toString();
    });
    child.stderr.on("data", (data: Buffer) => {
      stderr += data.toString();
    });

    child.on("error", () => {
      resolve({ stdout, stderr, code: 1 });
    });

    child.on("close", (code: number | null) => {
      resolve({ stdout, stderr, code: code ?? 1 });
    });

    child.stdin.write(stdinJson);
    child.stdin.end();
  });
}

// --- Read and parse hooks config ---

function readHooksConfig(cwd: string): HooksConfig | null {
  const settingsPath = path.join(cwd, ".claude", "settings.json");
  const localPath = path.join(cwd, ".claude", "settings.local.json");

  let config: HooksConfig = {};

  try {
    const content = fs.readFileSync(settingsPath, "utf-8");
    config = JSON.parse(content);
  } catch {
    return null;
  }

  // Merge local overrides
  try {
    const localContent = fs.readFileSync(localPath, "utf-8");
    const localConfig = JSON.parse(localContent) as HooksConfig;
    if (localConfig.hooks) {
      config.hooks = { ...config.hooks, ...localConfig.hooks };
    }
  } catch {
    // No local overrides
  }

  if (!config.hooks) return null;

  return config;
}

// --- Check if a tool name matches a hook's matcher ---

function matchesTool(matcher: string | undefined, toolName: string): boolean {
  if (!matcher || matcher === "" || matcher === "*") return true;
  try {
    return new RegExp(matcher).test(toolName);
  } catch {
    return false;
  }
}

// --- Run all matching hooks for an event ---

async function runHooks(
  matcherGroups: MatcherGroup[],
  toolName: string,
  stdinJson: string,
  cwd: string,
): Promise<{ failed: boolean; output: string }> {
  const ccToolName = mapToolName(toolName);
  let allOutput = "";
  let anyFailed = false;

  for (const group of matcherGroups) {
    if (!matchesTool(group.matcher, ccToolName)) continue;

    for (const hook of group.hooks) {
      if (hook.type !== "command") continue;

      const result = await execHookCommand(hook.command, stdinJson, cwd, 30000);

      const output = [result.stdout, result.stderr]
        .filter(Boolean)
        .join("\n")
        .trim();

      if (output) {
        allOutput += (allOutput ? "\n" : "") + output;
      }

      if (result.code !== 0) {
        anyFailed = true;
      }
    }
  }

  return { failed: anyFailed, output: allOutput };
}

// --- Extension entry point ---

export default function (pi: ExtensionAPI) {
  let hooksConfig: HooksConfig | null = null;

  pi.on("session_start", async (_event, ctx) => {
    hooksConfig = readHooksConfig(ctx.cwd);
  });

  // PreToolUse → tool_call (can block)
  pi.on("tool_call", async (event, ctx) => {
    if (!hooksConfig?.hooks?.PreToolUse?.length) return;

    const stdinJson = JSON.stringify({
      cwd: ctx.cwd,
      hook_event_name: "PreToolUse",
      tool_name: mapToolName(event.toolName),
      tool_input: buildToolInput(
        event.toolName,
        event.input as Record<string, unknown>,
      ),
    });

    const { failed, output } = await runHooks(
      hooksConfig.hooks.PreToolUse,
      event.toolName,
      stdinJson,
      ctx.cwd,
    );

    if (failed) {
      return {
        block: true,
        reason: output || "Blocked by Claude Code PreToolUse hook",
      };
    }
  });

  // PostToolUse → tool_result (can modify result)
  pi.on("tool_result", async (event, ctx) => {
    if (!hooksConfig?.hooks?.PostToolUse?.length) return;
    if (event.isError) return;

    if (ctx.hasUI) {
      ctx.ui.setStatus("cc-hooks", "Running hooks...");
    }

    const stdinJson = JSON.stringify({
      cwd: ctx.cwd,
      hook_event_name: "PostToolUse",
      tool_name: mapToolName(event.toolName),
      tool_input: buildToolInput(
        event.toolName,
        event.input as Record<string, unknown>,
      ),
    });

    const { failed, output } = await runHooks(
      hooksConfig.hooks.PostToolUse,
      event.toolName,
      stdinJson,
      ctx.cwd,
    );

    if (ctx.hasUI) {
      ctx.ui.setStatus("cc-hooks", undefined);
    }

    if (failed) {
      return {
        content: [
          ...(event.content || []),
          {
            type: "text" as const,
            text: `\n\n[PostToolUse hook failed]\n${output}\n\nPlease fix the issues above.`,
          },
        ],
        isError: true,
      };
    }
  });

  // Stop → agent_end (fire-and-forget)
  pi.on("agent_end", async (_event, ctx) => {
    if (!hooksConfig?.hooks?.Stop?.length) return;

    const stdinJson = JSON.stringify({
      cwd: ctx.cwd,
      hook_event_name: "Stop",
    });

    for (const group of hooksConfig.hooks.Stop) {
      if (!matchesTool(group.matcher, "")) continue;
      for (const hook of group.hooks) {
        if (hook.type !== "command") continue;
        execHookCommand(hook.command, stdinJson, ctx.cwd, 30000).catch(
          () => {},
        );
      }
    }
  });
}
