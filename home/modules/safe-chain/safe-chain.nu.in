# safe-chain nushell wrappers
# Intercepts package manager commands through aikido for security scanning
# Respects direnv/devshell - always uses the npm/pnpm/etc from current PATH

def --wrapped npm [...args: string] {
    if ($args | length) > 0 and ($args | first) == "--safe-chain-version" {
        print "safe-chain (active via Nix wrapper)"
        return
    }
    let externals = (which -a npm | where type == "external")
    if ($externals | is-empty) { error make { msg: "No external npm found in PATH" } }
    let real_bin = ($externals | get path | first)
    let temp_bin = $"(^mktemp -d)/bin"
    ^mkdir -p $temp_bin
    ^ln -s $real_bin $"($temp_bin)/npm"
    with-env { PATH: $"($temp_bin):($env.PATH)" } { ^@aikido_npm@ ...$args }
}

def --wrapped npx [...args: string] {
    if ($args | length) > 0 and ($args | first) == "--safe-chain-version" {
        print "safe-chain (active via Nix wrapper)"
        return
    }
    let externals = (which -a npx | where type == "external")
    if ($externals | is-empty) { error make { msg: "No external npx found in PATH" } }
    let real_bin = ($externals | get path | first)
    let temp_bin = $"(^mktemp -d)/bin"
    ^mkdir -p $temp_bin
    ^ln -s $real_bin $"($temp_bin)/npx"
    with-env { PATH: $"($temp_bin):($env.PATH)" } { ^@aikido_npx@ ...$args }
}

def --wrapped yarn [...args: string] {
    if ($args | length) > 0 and ($args | first) == "--safe-chain-version" {
        print "safe-chain (active via Nix wrapper)"
        return
    }
    let externals = (which -a yarn | where type == "external")
    if ($externals | is-empty) { error make { msg: "No external yarn found in PATH" } }
    let real_bin = ($externals | get path | first)
    let temp_bin = $"(^mktemp -d)/bin"
    ^mkdir -p $temp_bin
    ^ln -s $real_bin $"($temp_bin)/yarn"
    with-env { PATH: $"($temp_bin):($env.PATH)" } { ^@aikido_yarn@ ...$args }
}

def --wrapped pnpm [...args: string] {
    if ($args | length) > 0 and ($args | first) == "--safe-chain-version" {
        print "safe-chain (active via Nix wrapper)"
        return
    }
    let externals = (which -a pnpm | where type == "external")
    if ($externals | is-empty) { error make { msg: "No external pnpm found in PATH" } }
    let real_bin = ($externals | get path | first)
    let temp_bin = $"(^mktemp -d)/bin"
    ^mkdir -p $temp_bin
    ^ln -s $real_bin $"($temp_bin)/pnpm"
    with-env { PATH: $"($temp_bin):($env.PATH)" } { ^@aikido_pnpm@ ...$args }
}

def --wrapped pnpx [...args: string] {
    if ($args | length) > 0 and ($args | first) == "--safe-chain-version" {
        print "safe-chain (active via Nix wrapper)"
        return
    }
    let externals = (which -a pnpx | where type == "external")
    if ($externals | is-empty) { error make { msg: "No external pnpx found in PATH" } }
    let real_bin = ($externals | get path | first)
    let temp_bin = $"(^mktemp -d)/bin"
    ^mkdir -p $temp_bin
    ^ln -s $real_bin $"($temp_bin)/pnpx"
    with-env { PATH: $"($temp_bin):($env.PATH)" } { ^@aikido_pnpx@ ...$args }
}

def --wrapped bun [...args: string] {
    if ($args | length) > 0 and ($args | first) == "--safe-chain-version" {
        print "safe-chain (active via Nix wrapper)"
        return
    }
    let externals = (which -a bun | where type == "external")
    if ($externals | is-empty) { error make { msg: "No external bun found in PATH" } }
    let real_bin = ($externals | get path | first)
    let temp_bin = $"(^mktemp -d)/bin"
    ^mkdir -p $temp_bin
    ^ln -s $real_bin $"($temp_bin)/bun"
    with-env { PATH: $"($temp_bin):($env.PATH)" } { ^@aikido_bun@ ...$args }
}

def --wrapped bunx [...args: string] {
    if ($args | length) > 0 and ($args | first) == "--safe-chain-version" {
        print "safe-chain (active via Nix wrapper)"
        return
    }
    let externals = (which -a bunx | where type == "external")
    if ($externals | is-empty) { error make { msg: "No external bunx found in PATH" } }
    let real_bin = ($externals | get path | first)
    let temp_bin = $"(^mktemp -d)/bin"
    ^mkdir -p $temp_bin
    ^ln -s $real_bin $"($temp_bin)/bunx"
    with-env { PATH: $"($temp_bin):($env.PATH)" } { ^@aikido_bunx@ ...$args }
}

def --wrapped pip [...args: string] {
    if ($args | length) > 0 and ($args | first) == "--safe-chain-version" {
        print "safe-chain (active via Nix wrapper)"
        return
    }
    let externals = (which -a pip | where type == "external")
    if ($externals | is-empty) { error make { msg: "No external pip found in PATH" } }
    let real_bin = ($externals | get path | first)
    let temp_bin = $"(^mktemp -d)/bin"
    ^mkdir -p $temp_bin
    ^ln -s $real_bin $"($temp_bin)/pip"
    with-env { PATH: $"($temp_bin):($env.PATH)" } { ^@aikido_pip@ ...$args }
}

def --wrapped pip3 [...args: string] {
    if ($args | length) > 0 and ($args | first) == "--safe-chain-version" {
        print "safe-chain (active via Nix wrapper)"
        return
    }
    let externals = (which -a pip3 | where type == "external")
    if ($externals | is-empty) { error make { msg: "No external pip3 found in PATH" } }
    let real_bin = ($externals | get path | first)
    let temp_bin = $"(^mktemp -d)/bin"
    ^mkdir -p $temp_bin
    ^ln -s $real_bin $"($temp_bin)/pip3"
    with-env { PATH: $"($temp_bin):($env.PATH)" } { ^@aikido_pip3@ ...$args }
}
